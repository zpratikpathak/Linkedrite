name: Deploy LinkedRite SaaS

on:
  push:
    branches:
      - master

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Create .env file
      run: echo "${{ secrets.ENVIRONMENTAL_VARIABLES }}" > .env

    - name: Create docker-compose.prod.yml
      run: |
        cat > docker-compose.prod.yml << 'EOF'
        services:
          web:
            image: linkedrite:latest
            restart: always
            ports:
              - "8000:8000"
            env_file:
              - .env
            depends_on:
              - db
              - redis
            networks:
              - linkedrite-network
            healthcheck:
              test: ["CMD", "curl", "-f", "http://localhost:8000/admin/"]
              interval: 30s
              timeout: 10s
              retries: 3
              start_period: 40s
          
          db:
            image: postgres:15-alpine
            restart: always
            env_file:
              - .env
            environment:
              POSTGRES_DB: ${POSTGRES_DB:-linkedrite}
              POSTGRES_USER: ${POSTGRES_USER:-linkedrite}
              POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-linkedrite123}
            volumes:
              - postgres_data:/var/lib/postgresql/data
            networks:
              - linkedrite-network
            healthcheck:
              test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-linkedrite}"]
              interval: 10s
              timeout: 5s
              retries: 5
          
          redis:
            image: redis:7-alpine
            restart: always
            command: redis-server --maxmemory 256mb --maxmemory-policy allkeys-lru
            volumes:
              - redis_data:/data
            networks:
              - linkedrite-network
            healthcheck:
              test: ["CMD", "redis-cli", "ping"]
              interval: 10s
              timeout: 5s
              retries: 5
        
        networks:
          linkedrite-network:
            driver: bridge
        
        volumes:
          postgres_data:
          redis_data:
        EOF

    - name: Build Docker image
      run: |
        # Build with build argument to bust cache if requirements changed
        docker build . -t linkedrite:latest \
          --build-arg REQUIREMENTS_HASH=$(sha256sum requirements.txt | cut -d' ' -f1)
        docker tag linkedrite:latest linkedrite:${{ github.sha }}

    - name: Save Docker images
      run: |
        docker save linkedrite:latest linkedrite:${{ github.sha }} | gzip > linkedrite-images.tar.gz

    - name: Create deployment script
      run: |
        cat > deploy.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "Starting LinkedRite SaaS deployment..."
        
        # Navigate to deployment directory
        cd ~/linkedrite
        
        # Function to free port 8000
        free_port_8000() {
          echo "Checking if port 8000 is in use..."
          
          # Find process using port 8000
          PORT_PID=$(sudo lsof -t -i:8000 || true)
          
          if [ ! -z "$PORT_PID" ]; then
            echo "Port 8000 is in use by PID: $PORT_PID"
            
            # Try to identify the process
            PROCESS_INFO=$(ps -p $PORT_PID -o comm= 2>/dev/null || echo "unknown")
            echo "Process: $PROCESS_INFO"
            
            # Kill the process
            echo "Stopping process using port 8000..."
            sudo kill -9 $PORT_PID || true
            sleep 2
          fi
          
          # Also check for any Docker container using port 8000
          echo "Checking for Docker containers using port 8000..."
          CONTAINERS=$(docker ps --format "table {{.ID}}\t{{.Names}}\t{{.Ports}}" | grep -E "0\.0\.0\.0:8000|:::8000" | awk '{print $1}' || true)
          
          if [ ! -z "$CONTAINERS" ]; then
            echo "Found Docker containers using port 8000:"
            echo "$CONTAINERS"
            for CONTAINER in $CONTAINERS; do
              if [ "$CONTAINER" != "CONTAINER" ]; then
                echo "Stopping container: $CONTAINER"
                docker stop $CONTAINER || true
                docker rm $CONTAINER || true
              fi
            done
          fi
          
          # Clean up any linkedrite containers
          echo "Cleaning up any existing linkedrite containers..."
          docker ps -a | grep linkedrite | awk '{print $1}' | xargs -r docker rm -f || true
          
          echo "Port 8000 is now free"
        }
        
        # Free port 8000 before deployment
        free_port_8000
        
        # Load Docker images
        echo "Loading Docker images..."
        docker load < linkedrite-images.tar.gz
        
        # Backup current .env if exists
        if [ -f .env ]; then
          cp .env .env.backup.$(date +%Y%m%d_%H%M%S)
        fi
        
        # Stop and remove old containers (if any)
        echo "Stopping old containers..."
        docker-compose -f docker-compose.prod.yml down || true
        
        # Remove old images to free up space
        docker image prune -f
        
        # Start services
        echo "Starting services..."
        docker-compose -f docker-compose.prod.yml up -d
        
        # Wait for services to initialize
        echo "Waiting for services to initialize..."
        sleep 15
        
        # The entrypoint script handles migrations, admin creation, and static files
        # Just check if everything is running properly
        
        # Check container health
        echo "Checking container health..."
        docker-compose -f docker-compose.prod.yml ps
        
        # Clean up
        echo "Cleaning up..."
        rm -f linkedrite-images.tar.gz
        
        # Show logs from last 50 lines
        echo "Recent logs from web container:"
        docker-compose -f docker-compose.prod.yml logs --tail=50 web
        
        echo "Deployment completed successfully!"
        echo "LinkedRite is now accessible at http://$(hostname -I | awk '{print $1}'):8000"
        EOF
        
        chmod +x deploy.sh

    - name: Copy files to server
      uses: appleboy/scp-action@master
      with:
        host: ${{ secrets.SERVER_HOST }}
        username: ${{ secrets.SERVER_USERNAME }}
        key: ${{ secrets.SSH_KEY }}
        port: ${{ secrets.SSH_PORT }}
        source: "linkedrite-images.tar.gz,docker-compose.prod.yml,.env,deploy.sh,scripts/fix-*.sh"
        target: "~/linkedrite/"
        strip_components: 0
        overwrite: true
        rm: true

    - name: Execute deployment on server
      uses: appleboy/ssh-action@master
      with:
        host: ${{ secrets.SERVER_HOST }}
        username: ${{ secrets.SERVER_USERNAME }}
        key: ${{ secrets.SSH_KEY }}
        port: ${{ secrets.SSH_PORT }}
        script: |
          cd ~/linkedrite
          ./deploy.sh
          
          # Verify deployment
          echo "Verifying deployment..."
          sleep 10
          
          # Check if web container is running
          CONTAINER_STATUS=$(docker-compose -f docker-compose.prod.yml ps web | grep -E "Up|running" || true)
          if [ -n "$CONTAINER_STATUS" ]; then
            echo "âœ… Web container is running"
            echo "$CONTAINER_STATUS"
          else
            echo "âš ï¸ Web container status unclear, checking logs..."
            docker-compose -f docker-compose.prod.yml logs --tail=20 web
          fi
          
          # Test if application responds (with retries)
          echo "Testing application response..."
          MAX_ATTEMPTS=5
          ATTEMPT=1
          
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "Attempt $ATTEMPT of $MAX_ATTEMPTS..."
            
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8000 || echo "000")
            
            if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "302" ] || [ "$HTTP_STATUS" = "301" ]; then
              echo "âœ… Application is responding (HTTP $HTTP_STATUS)"
              echo "ðŸŽ‰ Deployment successful! LinkedRite is running on port 8000"
              echo "URL: http://${{ secrets.SERVER_HOST }}:8000"
              exit 0
            else
              echo "Response: HTTP $HTTP_STATUS"
              if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
                echo "Waiting before retry..."
                sleep 5
              fi
            fi
            
            ATTEMPT=$((ATTEMPT + 1))
          done
          
          # If we get here, verification failed
          echo "âš ï¸ Application verification uncertain after $MAX_ATTEMPTS attempts"
          echo "However, the container is running. Manual verification recommended."
          echo ""
          echo "Container status:"
          docker-compose -f docker-compose.prod.yml ps
          echo ""
          echo "Recent logs:"
          docker-compose -f docker-compose.prod.yml logs --tail=30 web
          echo ""
          echo "You can manually check: http://${{ secrets.SERVER_HOST }}:8000"
          
          # Exit with success since the container is running
          exit 0

    - name: Cleanup local files
      if: always()
      run: |
        rm -f linkedrite-images.tar.gz
        rm -f docker-compose.prod.yml
        rm -f .env
        rm -f deploy.sh
